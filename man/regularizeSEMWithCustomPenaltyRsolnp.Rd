% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/regularizeSEMWithCustomPenalty.R
\name{regularizeSEMWithCustomPenaltyRsolnp}
\alias{regularizeSEMWithCustomPenaltyRsolnp}
\title{regularizeSEMWithCustomPenaltyRsolnp}
\usage{
regularizeSEMWithCustomPenaltyRsolnp(
  lavaanModel,
  individualPenaltyFunction,
  tuningParameters,
  penaltyFunctionArguments,
  startingValues = "est",
  saveHessian = FALSE,
  control = list(trace = 0)
)
}
\arguments{
\item{lavaanModel}{model of class lavaan}

\item{individualPenaltyFunction}{penalty function which takes the current parameter values as first argument, the tuning parameters as second, and the penaltyFunctionArguments as third argument and 
returns a single value - the value of the penalty function for a single person. If the true penalty function is non-differentiable (e.g., lasso) a smooth
approximation of this function should be provided.}

\item{tuningParameters}{data.frame with tuning parameter values. Important: The function will iterate over the rows of these tuning parameters and pass them to your penalty function}

\item{penaltyFunctionArguments}{arguments passed to individualPenaltyFunction, individualPenaltyFunctionGradient, and individualPenaltyFunctionHessian}

\item{startingValues}{option to provide initial starting values. Only used for the first lambda. Three options are supported. Setting to "est" will use the estimates
from the lavaan model object. Setting to "start" will use the starting values of the lavaan model. Finally, a labeled vector with parameter
values can be passed to the function which will then be used as starting values.}

\item{saveHessian}{should the Hessian of the optimizer be saved? This will take a lot of space!}

\item{control}{option to set parameters of the optimizer; see ?Rsolnp::solnp}
}
\description{
Optimize a SEM with custom penalty function using the Rsolnp optimizer (see ?Rsolnp::solnp). This optimizer is the default in regsem (see ?regsem::cv_regsem).
}
\examples{
library(aCV4SEM)

# Identical to regsem, aCV4SEM builds on the lavaan
# package for model specification. The first step
# therefore is to implement the model in lavaan.

dataset <- simulateExampleData()

lavaanSyntax <- "
f =~ l1*y1 + l2*y2 + l3*y3 + l4*y4 + l5*y5 +
     l6*y6 + l7*y7 + l8*y8 + l9*y9 + l10*y10 +
     l11*y11 + l12*y12 + l13*y13 + l14*y14 + l15*y15
f ~~ 1*f
"

lavaanModel <- lavaan::sem(lavaanSyntax,
                           data = dataset,
                           meanstructure = TRUE,
                           std.lv = TRUE)

# Optional: Plot the model
# semPlot::semPaths(lavaanModel,
#                   what = "est",
#                   fade = FALSE)

## Defining a custom penalty function is a bit more complicated than
# using the default ones provided in regularizeSEM (see ?aCV4SEM::regularizeSEM).
# We start with the definition of the penalty function. Make sure that the derivatives
# of this function are well defined (i.e., the function is smooth)!
# We will use the lasso penalty as an example.

# The penalty function MUST accept three arguments; how you use them is up to you.

# The first argument are the parameters. aCV4SEM will pass a vector with the current
# parameter values and their names to your function. The parameter labels will be
# exactly the same as those used by lavaan! So you can check them before with:

aCV4SEM::getLavaanParameters(lavaanModel)

# The vector passed to your function will look like the vector above.

# The second argument is called tuningParameters MUST be a data.frame with the
# tuning-parameters. aCV4SEM will automatically iterate over the rows of this object.
# In case of LASSO regularization there is only one tuning parameter: lambda.
# Therefore, we specify the tuningParameters object as:

tuningParameters <- data.frame(lambda = seq(0,1,.1)) # we will test 11 lambdas here
print(tuningParameters)

# The third argument is called penaltyFunctionArguments and we can pass anything
# we want here. For the lasso penalty, we need two additional things:
# 1) We need the smoothing-parameter epsilon, which makes sure that our
# penalty is differentiable
# 2) We need the labels of the regularized parameters, so that we can only
# penalize those while all others remain unpenalized.

penaltyFunctionArguments <- list(
  eps = 1e-10,
  regularizedParameterLabels = paste0("l", 6:15)
)

# Now, it is time to specify our custom penalty function:

smoothLASSO <- function(
  # here are our three arguments:
  parameters,
  tuningParameters,
  penaltyFunctionArguments
){
  # to make it easier to see what is going on:
  lambda <- tuningParameters$lambda # tuningParameters will be ONE ROW OF the
  # tuningParameters object we created before -> it will contain just
  # one lambda in this case!
  eps <- penaltyFunctionArguments$eps
  regularizedParameterLabels <- penaltyFunctionArguments$regularizedParameterLabels

  regularizedParameters <- parameters[regularizedParameterLabels]

  # now, let's define our penalty function:
  penaltyLasso <- lambda*sum(sqrt(regularizedParameters^2 + eps))

  return(penaltyLasso)
}
# Important: This penalty function is assumed to be for a single individual only.
# aCV4SEM will multiply it with sample size N to get the penalty value of the
# full sample!

#### Now we are ready to optimize! ####
regsemApprox <- regularizeSEMWithCustomPenaltyRsolnp(lavaanModel = lavaanModel,
                                               individualPenaltyFunction = smoothLASSO,
                                               tuningParameters = tuningParameters,
                                               penaltyFunctionArguments = penaltyFunctionArguments)

# let's compare the results to an exact optimization:

regsemExact <- regularizeSEM(
  lavaanModel = lavaanModel,
  regularizedParameterLabels = paste0("l", 6:15),
  penalty = "lasso",
  lambdas = tuningParameters$lambda)

head(regsemExact@parameters[,regsemExact@parameterLabels] -
       regsemApprox@parameters[,regsemExact@parameterLabels])
# Note that the parameter estimates are basically identical.

## To select a model, we used the approximate cross-validation function:
aCV <- aCV4regularizedSEMWithCustomPenalty(regularizedSEMWithCustomPenalty = regsemApprox,
                                           k = nrow(dataset))
plot(aCV)
# To extract the best parameter estimates:
coef(aCV)
}
