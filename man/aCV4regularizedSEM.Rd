% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aCV4model.R
\name{aCV4regularizedSEM}
\alias{aCV4regularizedSEM}
\title{aCV4regularizedSEM}
\usage{
aCV4regularizedSEM(
  regularizedSEM,
  k,
  recomputeHessian = TRUE,
  returnSubsetParameters = FALSE,
  control = controlGLMNET()
)
}
\arguments{
\item{regularizedSEM}{model of class regularizedSEM}

\item{k}{the number of cross-validation folds. We recommend leave-one-out cross-validation; i.e. set k to the number of persons in the data set. Alternatively, 
a matrix with pre-defined subsets can be passed to the function. See ?linr::aCV4regularizedSEM for an example}

\item{recomputeHessian}{if set to FALSE, the Hessians from the quasi newton optimization with GLMNET will be used. Otherwise the Hessian will be recomputed. We currently recommend setting recomputeHessian to TRUE}

\item{returnSubsetParameters}{if set to TRUE, the parameter estimates of the individual cross-validation training sets will be returned}

\item{control}{parameters passed to the GLMNET optimizer. Note that only arguments of the inner iteration are used. See ?controlGLMNET for more details}
}
\description{
approximate cross-validation for models of class regularizedSEM. These models can be fit with regularizedSEM() (see ?regularizedSEM)
in this package.
}
\examples{
library(linr)

# Let's first set up a regularized model. The following steps are
# explained in detail in ?linr::regularizeSEM
dataset <- simulateExampleData()

lavaanSyntax <- "
f =~ l1*y1 + l2*y2 + l3*y3 + l4*y4 + l5*y5 + 
     l6*y6 + l7*y7 + l8*y8 + l9*y9 + l10*y10 + 
     l11*y11 + l12*y12 + l13*y13 + l14*y14 + l15*y15
f ~~ 1*f
"

lavaanModel <- lavaan::sem(lavaanSyntax,
                           data = dataset,
                           meanstructure = TRUE,
                           std.lv = TRUE)

# Optional: Plot the model
# semPlot::semPaths(lavaanModel, 
#                   what = "est",
#                   fade = FALSE)

regsem <- regularizeSEM(
  lavaanModel = lavaanModel,
  regularizedParameterLabels = paste0("l", 6:15),
  penalty = "lasso",
  nLambdas = 5)
plot(regsem)

## The approximate cross-validation can be computed with:
aCV <- aCV4regularizedSEM(regularizedSEM = regsem,
                          # we highly recommend that you use approximate
                          # leave one out cross-validation:
                          k = nrow(dataset)
)
# let's plot the parameter values and the corresponding leave-one-out fit:
plot(aCV)

# the best parameters can be extracted with
coef(aCV)

# we can also use the one standard deviation rule:
coef(aCV, rule = "1sd")

# To see which person ended up in which sample, use:
aCV@subsets

#### Advanced ####
# If you are interested in the parameter estimates of each sub-sample,
# you must re-run the computation with returnSubsetParameters set to TRUE.
# This is disabled by default because it may take a lot of disk space
aCV <- aCV4regularizedSEM(regularizedSEM = regsem,
                          k = nrow(dataset),
                          returnSubsetParameters = TRUE
)

# the parameter are returned in a 3D-array. The subsets are in the
# rows, the parameters in the columns and the tuning parameters in
# the third dimension. To access the elements, use:
# Access elements for:
dimnames(aCV@subsetParameters)[[3]][1]
aCV@subsetParameters[,,1] # first lambda value
# Access elements for:
dimnames(aCV@subsetParameters)[[3]][2]
aCV@subsetParameters[,,2] # second lambda value

## Currently, aCV4regularizedSEM recomputes the Hessian for each configuration
# of the tuning parameters. To reuse the Hessian of the previous optimiztation, use:
regsem <- regularizeSEM(
  lavaanModel = lavaanModel,
  regularizedParameterLabels = paste0("l", 6:15),
  penalty = "lasso",
  nLambdas = 5,
  control = controlGLMNET(saveHessian = TRUE)) # save the Hessian of the optimizer

aCV <- aCV4regularizedSEM(regularizedSEM = regsem,
                          k = nrow(dataset),
                          recomputeHessian = FALSE # don't recompute Hessian
                          
)

## Instead of letting linr create the subsets, you can
# also pass your own subsets. As an example:
subsets <- linr:::createSubsets(N = nrow(dataset), k  = 10)

aCV <- aCV4regularizedSEM(regularizedSEM = regsem,
                          k = subsets
)
aCV@cvfitsDetails
}
